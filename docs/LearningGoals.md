# Learning Goals
The learning goal I personally set for myself for this project was to get familiar with the following technologies. I will cover the motivation to learn about the technology, any issues I faced while working with it as well as what I could do in addition to learn more about it in the future.

## OpenLayers
Despite having worked with projects utilizing OpenLayers for one and a half years, I never got much experience working on the map itself. The most complex issue I had worked on was just updating the API from which the application got its tiles from.  
My previous experience using OpenLayers's documentation was that it is relatively confusing and that you had to know a fair bit before they would prove to be useful in any meaningful capacity. I would still say that I hold this position as trying to figure out how to do anything without the proper vocabulary proved to be fairly difficult. This improved as time went on and I had spent more time working things out. There were some pitfalls that I couldn't quite figure out from various tutorials, but towards the end I felt more comfortable using a mixture of tutorials and documentation to implement the functionality I wanted to implement.  
Currently I would still want to revisit the implementations of interacting with the map. I think I could implement the Draw interaction as a custom click interaction on the map instead. I would want to implement the draw interaction to avoid creating Points on top of other points and I imagine there could be some logic like the Select interaction's hitTolerance that could be used to look for collisions.

## VectorTileLayer
The previous OpenLayers maps I've worked with have used raster tiles for their background maps. I always found these to be visually clunky especially compared to Google maps, so I've wanted to experiment with vector tiles to see how their performance in local development compares to raster tiles. I would say that I overall prefer how zooming in and out looks on vector tiles even though the used map doesn't have a whole lot of detail in it compared to most raster tiles I've used.  
There surprisingly weren't many issues getting the VectorTileLayer to work, I would say the only major issue was the select interaction being able to select features from that layer aswell before I learned you could specify the layers for a Select object. 
I would certainly want to experiment more with the VectorTileLayer as all of the configurations are currently from a tutorial. The .topojson files received from the API include various other objects that could be added to the map view. Adding places or PoIs could be a good exercise to figure out how the rules object used in the layer definition works.

## Django
Django was a wildcard in the technologies used. I had not used it or anything similar in Python before, so I went in with an open mind and a tutorial on the second monitor. Turns out, Django is quite nice for creating simple backend services and the option to easily create an admin management view is interesting. 
I personally enjoy digging through the database manually, so I'm not completely sold on the ORM elements of Django yet. Initially my plan was to use the Postgis extension for the database, but there seemed to be more additional steps to setting up Django for it and the database was only going to hold points so I decided to pass on the option this time (perhaps for the better as there were quite a few elements already that required me to learn and read documentation).  
Perhaps to take this project further, I could look into adding the Postgis dependencies and I could try to implement some features that could leverage the geometry database objects and the functions included with Postgis.  
Another point to revisit at a later time would be the authentication scheme I used. The better choice would be to use a session-token based authentication instead of the silly idea of storing a basic authentication token in the cookies. I should also look into how other web applications handle transferring the login or register requests to the backend. I wondered if simply using a secure connection is all that is done or is there more obfuscation on the request body as a whole.

## Nginx
I have very little prior experience with Nginx. At the start I only wanted something to simply host the webpage but as the project went on I kept wanting to do more with it, namely reverse proxies. I spent a long time trying to create a functioning reverse proxy for the Vector tile API nextzen, but after many hours of debugging, I just couldn't manage to add the query parameter of the api_key to the proxy request. Currently I'm not happy having the api-key in both the static asset files as well as in the requests made by the browser and I would like to revisit this and try to get it to work eventually.  
I wanted to succeed in at least one reverse proxy, so I settled with the easiest one; the simple backend Django API. It had no query parameters so the downfall of my last attempt wouldn't come back to haunt me. Optimally I would have wanted to include the admin page in a reverse proxy aswell so I wouldn't need to open any ports from the backend container to the public, but for the time being I feel like taking a break from trying to understand Nginx any further.
